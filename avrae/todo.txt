!play darts
*   make it clear what the aim was
*   make an explicit x1 so it doesn't automatically double in or tripple
*   eye or bull argument should translate to `50` outer to 25
*   Default straight in double out
*   Double out on bullseye
- links to rules for darts, blackjack, killer ones, hoard
    https://docs.google.com/document/d/1JugoNch6eVNTNVVgo05uT0O1Y-ie4s1WKUAAWtg1pQA/edit?usp=sharing
    https://bicyclecards.com/how-to-play/ship-captain-and-crew/
- dragon hoard can roll again if done on 1 or 2

BLOCK Initiative
- init treshold option
- block member treshold
- keep groups together
- next, tracking who flagged
- if not done, show embed
- if done, multiline i move , i next and end with embed showing group summary
- always next the whole block for dms or have a -f option


New treasure table
https://docs.google.com/spreadsheets/d/1S-8AUtZFoeQEtmKD5owg2kmbIpbBppgOP-X1S-JgQVk/edit#gid=1228159918

A bit like !mitable
* convert to json (done !gvar 1009a4b8-20b8-4892-8e7f-8259233128bf)
- (meh, would get terrible to display as well) nested table for weapons and stuff
    - nested sub rolls
    - list with even chance

!chance auto adding of save effects not done due to target/executor swap (already a one target limit)
- probably check effects during looping over targets, add boni the to target dict



- rspell SRD only (source
- October: new spells in dragon book, add to list(s) for rspell and other aliases

Item DB: spelling and use in #count (!qb # rope)
- solution 1: synonyms list or main one
- alt should be same or less words rearranged to not require partial matching duplication
Quickbag: count release & message

==== Random race npc generator

* Leaf: {"field":"val"} set field
* {int:<branch>, ...} weighted randomly select branch
* [<branch>,...] randomly selecy branch
* {"key":<branch>] branch off more fields
* {"field":"@ref} reference different branch in db.
*     if key is not directly found, check weighted randoms for "samekey:value" and select that {eg: "race":{5:{"race":"Human"}} matches race.Human
*     if value is a list: check all branches with dicts again for {'samekey':'Value'}
* None: dead end/unspecified option
* argument "key=Value": select from random list
*   or from random weighted based on sub key ( think I did at least because key:list already has to handle lists, can't look for sub key
* gender
- subrace (race flexible, configurable for area)
* age
    - Make age more numeric and race specific, be able to refer to rolled values as fields like age.roll and height.value
* name
- physical characteristics  (% for race)
    * eye color
    * hair color (age)
    * skin color (tan, pale)
    * size
    - disabilities/tattoos/specials
- hair color override by age: age: 100 { age:senior, "hair": {80% gray, 20%: None = keep}}
    - same for age and profession except override with real 'none'
- list result for multiple charateristics: roll string in key means roll and generate a number of results
    - '1d4': ['item','item']
    - '1d4': {weighted table} too
    - key starts with + then (also in stack) ? add to field
    - in representation format a list with commas or spaces,how now? commas for characteristics (and for last) but list for menu recipe


- birthplace (linked to subrace/race%)
    - Sword coast/waterdeep/faerun (can overlap area, doesnt matter), outlands, barovia, domains of dread, icewind dale
    - configurable template
    - from should be weighted table with only "plane":"prime, "continent":"fearun",
    - "from" specific over generic so from waterdeep for cities in faerun and from faerun if not specified
* Dice string detection, roll it
- update/override db with svar/uvar  TODO: what is syntax for this?
    - Should be possible to replace svar with gvar and it works
    - Should be possible to have an svar with a gvar {default="gvar",waterdeep={my own stuff}}
- gvar references in db so {[gvar,gvar,gvar]} as an svar just works, but how is updated instead of randomized? gvar+gvar+gvar?

    * relative references, otherwise gvar stuff will be weird
    * .. empty pointers remove the preceding, mostly for relative from current but could do .race..bla technically.
    * references with {field} so race.{race}.gender.{gender}, what to do if field undefined? postpone/error. right search order (should be json top down so)
    * keys that start with @ are not added to the stack (only for referal)
        * refering can be done to these without the extra @ eg { name:'@humannames', '@humannames':[foo,bar]}
- Text representation, replace fields (with bold or italic)
* weighted % is cumulative, but how mix { 1 5% 10 +5 }
    - problem 50% and 50% is duplicate key
# overrides: specific over generic (eye color in root is overridden by race/gender specific) due to order (breadth first? or just add new branch in front instead of end
* profession (race% and/or location %)

- tavern generator : two part name, barkeep (npc generator?)
- inn room rates (4+1d4 rooms, then list of rooms with rate
- menu rates (items drinks and items meals) meals two part 'poached' 'fish'

- backstory generator
    - player backgrounds/professions + a tragedy + goals/ideals + bonds/religion + flaws
- remaining races heights: https://preview.redd.it/51fh9i4c9q721.png?width=1128&format=png&auto=webp&s=e3be83a5ab34fe60ca870f03161b3b3f99866cba



Quickbag: count plurals
Quickbag undo undo = redo, mention in message.
Add coins to list

Remove packs
Change packs from rations to ration or keep rations in item list -.-

Remove ballbearings and other weird duplicates

Quickbag: adding plurals can now easily end up with two separate items in bag how to fix? Remove all plurals from the table and fix plural arguments in the same way?


state: finish var rename thing
state: skill bonuses (initiative, perception especially)
state: fields from !state combat (effects, conditions, range), separate default for targeted
state: server variable for defaults ?
